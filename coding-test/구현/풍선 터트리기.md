
```java
class Solution {
    public int solution(int[] a) {
        int answer = 2;

        int[] left = new int[a.length]; int[] right = new int[a.length];
        int l = a[0]; int r = a[a.length - 1];

        for (int i = 1; i < a.length; i++) {
            l = Math.min(l, a[i]);
            left[i] = l;
        }

        for (int i = a.length - 2; i > 0; i--) {
            r = Math.min(r, a[i]);
            right[i] = r;
        }

        for (int i = 1; i < a.length - 1; i++) {
            if (a[i] > left[i] && a[i] > right[i]) continue;
            answer++;
        }

        return answer;
    }
}
```

### 플랫폼
- 프로그래머스

### 난이도
- 3레벨

### 문제
```
일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.
```

### 아이디어
1. 번호가 더 작은 풍선을 터트리는 행위는 1번만 할 수 있다.
	1. **n - 1, n, n + 1 일 때, n > n-1 이고 n > n+1 이면 n은 남길 수 없다.
2. 각 인덱스까지의 풍선 최소값을 구하고, 위 논리를 적용한다.
3. 처음과 마지막 풍선은 무조건 남길 수 있다.