### 알고리즘 관점에서의 복잡도
- 알고리즘이 얼마나 효율적인지를 나타내는 지표
- 얼마만큼의 시간이 걸리는지 / 얼마만큼의 메모리를 사용하는지
- 알고리즘의 성능을 판단하는 척도

### 시간복잡도
- 실행되는 연산의 횟수
- 단순히 실행되는 연산의 횟수만 보는 것은 아니고,
  입력의 크기가 증가함에 따라 연산 횟수가 얼마나 증가하는지를 나타내는 것
- 입력과 시간의 함수 관계를 나타내는 개념

- 크게 3가지 표기법을 사용한다.
	- Big-O (빅-오) : 최악의 경우를 고려 (상한 접근)
	- Big-Ω (빅-오메가) : 최선의 경우를 고려 (하한 접근)
	- Big-θ (빅-세타) : 평균적인 경우를 고려

### 공간복잡도
- 실행될 때 필요로 하는 자원 공간의 양
- 최근에는 하드웨어의 발달로 메모리 공간이 넉넉해졌고,
  시간복잡도가 높을 때 비효율성이 훨씬 크기 때문에 시간복잡도를 우선적으로 고려한다.

### 질문
- 다른 것을 사용하지 않고, Big-O를 사용하는 이유는?
	- 최악의 경우를 고려하기 때문이다.
	- 상수 계수나 낮은 차수의 항을 무시하기 때문에 간결하고 직관적이다.

- 그럼 O(1) 알고리즘은 O(N^2) 알고리즘보다 무조건적으로 빠른가?
	- 이론적으로는 그렇다.
	- 하지만 빅-오 표기법은 최악의 경우를 고려한 수치이다.
	- 그러므로 상수 시간이 매우 크다면, 작은 N에 대해서는 O(N^2) 알고리즘이 더 빠를 수 있다.